require 'test_helper'

class PtOscMigrationIntegrationTest < ActiveRecord::TestCase
  class TestMigration < ActiveRecord::PtOscMigration; end

  context 'a migration' do
    setup do
      @migration = TestMigration.new
      @migration.stubs(:logger).returns(stub_everything)
    end

    context 'connected to a pt-osc database' do
      setup do
        ActiveRecord::Base.establish_connection(test_spec('test_execute'))
        @migration.instance_variable_set(:@connection, ActiveRecord::Base.connection)
      end

      context 'on an existing table with an existing column' do
        setup do
          @table_name = Faker::Lorem.word
          @index_name = Faker::Lorem.words.join('_')

          ActiveRecord::Base.connection.execute "DROP TABLE IF EXISTS `#{@table_name}`;"
          # can't use "id" because it's generated by Faker::Lorem.word :)
          ActiveRecord::Base.connection.execute <<-SQL
          CREATE TABLE `#{@table_name}` (
            `primary` int(11) NOT NULL AUTO_INCREMENT,
            PRIMARY KEY (`primary`)
          );
          SQL
        end

        teardown do
          ActiveRecord::Base.connection.execute "DROP TABLE IF EXISTS `#{@table_name}`;"
        end

        context 'new columns' do
          setup do
            @new_column_name = Faker::Lorem.word
            @arguments = [
              nil,
              @migration,
              @table_name,
              @new_column_name,
              {}
            ]
          end

          # Rails' "magic" time, for Time columns
          # https://github.com/rails/rails/blob/fcf9b712b1dbbcb8f48644e6f20676ad9480ba66/activerecord/lib/active_record/type/time.rb#L16
          base_date = Time.utc(2000, 1, 1, 0, 0, 0)

          datetime_value = Time.at(Time.now.to_i).utc # Date types we're testing don't have sub-second precision
          date_value = Time.utc(datetime_value.year, datetime_value.month, datetime_value.day)
          rails_time_value = Time.utc(base_date.year, base_date.month, base_date.day, datetime_value.hour, datetime_value.min, datetime_value.sec)

          [
            { type: :integer, default: 42 },
            { type: :string, default: ["'foobar'", ':bazqux'], expected_default: ['foobar', 'bazqux'] },
            { type: :text, default: nil }, # TEXT columns cannot have a default http://dev.mysql.com/doc/refman/5.7/en/blob.html#idm140380410069472
            { type: :float, default: 3.14159 },
            { type: :datetime, default: "'#{datetime_value.strftime('%F %T')}'", expected_default: datetime_value },
            { type: :time, default: "'#{datetime_value.strftime('%T')}'", expected_default: rails_time_value },
            { type: :date, default: "'#{datetime_value.strftime('%F')}'", expected_default: date_value },
            { type: :binary, default: nil }, # BLOB columns cannot have a default http://dev.mysql.com/doc/refman/5.7/en/blob.html#idm140380410069472
            { type: :boolean, default: [false, true] },
          ].each do |test|

            defaults = [test[:default]].flatten(1).compact # remove nils for columns that can't have a default
            expected_defaults = test[:expected_default] ? [test[:expected_default]].flatten(1) : defaults

            should "add a nullable #{test[:type]} column with default null" do
              column_name = "#{@new_column_name}_#{test[:type]}"
              @arguments[0] = "add_column :#{@table_name}, :#{column_name}, :#{test[:type]}, default: nil, null: true"
              @arguments[-2] = column_name
              @arguments[-1] = { type: test[:type], null: true, default: nil }
              migrate_and_test_field *@arguments
            end

            defaults.each_with_index do |default, index|
              should "add a nullable #{test[:type]} column with default value #{default}" do
                column_name = "#{@new_column_name}_#{test[:type]}"
                @arguments[0] = "add_column :#{@table_name}, :#{column_name}, :#{test[:type]}, default: #{default}, null: true"
                @arguments[-2] = column_name
                @arguments[-1] = { type: test[:type], null: true, default: expected_defaults[index] }
                migrate_and_test_field *@arguments
              end

              should "add a not-nullable #{test[:type]} column with default value #{default}" do
                column_name = "#{@new_column_name}_#{test[:type]}"
                @arguments[0] = "add_column :#{@table_name}, :#{column_name}, :#{test[:type]}, default: #{default}, null: false"
                @arguments[-2] = column_name
                @arguments[-1] = { type: test[:type], null: false, default: expected_defaults[index] }
                migrate_and_test_field *@arguments
              end
            end
          end
        end
      end
    end
  end
end
